Counter
	Special dictionary used for counting data, measuring frequency
	
	from collections import Counter
	nyc_eatery_count_by_types = Counter(nyc_eatery_types)
	print(nyc_eatery_count_by_type)
		Counter({'Mobile Food Truck': 114, 'Food Cart': 74, 'Snack Bar': 24, 'Specialty Cart': 18, 'Restaurant': 15, 'Fruit & Vegetable Cart': 4})
	print(nyc_eatery_count_by_types['Restaurant'])
		15
		
Counter to find the most common
	.most_common() method returns the counter values in descending order
	
	print(nyc_eatery_count_by_types.most_common(3))
		[('Mobile Food Truck', 114), ('Food Cart', 74), ('Snack Bar', 24)]

Exercise - Using Counter on lists

Counter is a powerful tool for counting, validating, and learning more about the elements within a dataset that is found in the collections module. You pass an iterable (list, set, tuple) or a dictionary to the Counter. You can also use the Counter object similarly to a dictionary with key/value assignment, for example counter[key] = value.

A common usage for Counter is checking data for consistency prior to using it, so let's do just that. In this exercise, you'll be using data from the Chicago Transit Authority on ridership.

		# Import the Counter object
		from collections import Counter

		# Print the first ten items from the stations list
		print(stations[:10])

		# Create a Counter of the stations list: station_count
		station_count = Counter(stations)

		# Print the station_count
		print(station_count)
		
Exercise - Finding most common elements

Another powerful usage of Counter is finding the most common elements in a list. This can be done with the .most_common() method.

Practice using this now to find the most common stations in a stations list.

		# Import the Counter object
		from collections import Counter

		# Create a Counter of the stations list: station_count
		station_count = Counter(stations)

		# Find the 5 most common elements
		print(station_count.most_common(5))


Using defaultdict
	Pass it a default type that every key will have even if it doesn't currently exist
	Works exactly like a dictionary

	from collections import defaultdict
	eateries_by_park = defaultdict(list)
	for park_id, name in nyc_eateries_parks: eateries_by_park[park_id].append(name)
	print(eateries_by_park['M010'])
		{'MOHAMMAD MATIN','PRODUCTS CORP.', 'Loeb Boathouse Restaurant','Nandita Inc.', 'SALIM AHAMED', 'THE NY PICNIC COMPANY','THE NEW YORK PICNIC COMPANY, INC.', 'NANDITA, INC.','JANANI FOOD SERVICE, INC.'}

	from collections import defaultdict
	eatery_contact_types = defaultdict(int)
	for eatery in nyc_eateries:
		if eatery.get('phone'):
			eatery_contact_types['phones'] += 1
		if eatery.get('website'):
			eatery_contact_types['websites'] += 1
	print(eatery_contact_types)
		defaultdict(<class 'int'>, {'phones': 28, 'websites': 31})
		
Exercise - Creating dictionaries of an unknown structure

Occasionally, you'll need a structure to hold nested data, and you may not be certain that the keys will all actually exist. This can be an issue if you're trying to append items to a list for that key. You might remember the NYC data that we explored in the video. In order to solve the problem with a regular dictionary, you'll need to test that the key exists in the dictionary, and if not, add it with an empty list.

You'll be working with a list of entries that contains ridership details on the Chicago transit system. You're going to solve this same type of problem with a much easier solution in the next exercise.

		# Create an empty dictionary: ridership
		ridership = {}

		# Iterate over the entries
		for date, stop, riders in entries:
			# Check to see if date is already in the ridership dictionary
			if date not in ridership:
				# Create an empty list for any missing date
				ridership[date] = []
			# Append the stop and riders as a tuple to the date keys list
			ridership[date].append((stop, riders))
			
		# Print the ridership for '03/09/2016'
		print(ridership['03/09/2016'])

Exercise - 	Safely appending to a key's value list

Often when working with dictionaries, you know the data type you want to have each key be; however, some data types such as lists have to be initialized on each key before you can append to that list.

A defaultdict allows you to define what each uninitialized key will contain. When establishing a defaultdict, you pass it the type you want it to be, such as a list, tuple, set, int, string, dictionary or any other valid type object.

		# Import defaultdict
		from collections import defaultdict

		# Create a defaultdict with a default type of list: ridership
		ridership = defaultdict(list)

		# Iterate over the entries
		for date, stop, riders in entries:
			# Use the stop as the key of ridership and append the riders to its value
			ridership[stop].append(riders)
			
		# Print the first 10 items of the ridership dictionary
		print(list(ridership.items())[:10])

Getting started with OrderedDict
	from collections import OrderedDict
	nyc_eatery_permits = OrderedDict()
	for eatery in nyc_eateries:
		nyc_eatery_permits[eatery['end_date']] = eatery
	print(list(nyc_eatery_permits.items())[:3]
		('2029-04-28', {'name': 'Union Square Seasonal Cafe', 'location': 'Union Square Park', 'park_id': 'M089', 'start_date': '2014-04-29', 'end_date': '2029-04-28', 'description': None, 'permit_number': 'M89-SB-R', 'phone': '212-677-7818', 'website': 'http://www.thepavilionnyc.com/', 'type_name': 'Restaurant'})

OrderedDict power feature
	.popitem() method returns items in reverse insertion order
	
	print(nyc_eatery_permits.popitem())
		('2029-04-28', {'name': 'Union Square Seasonal Cafe', 'location': 'Union Square Park', 'park_id': 'M089', 'start_date': '2014-04-29', 'end_date': '2029-04-28', 'description': None, 'permit_number': 'M89-SB-R', 'phone': '212-677-7818', 'website': 'http://www.thepavilionnyc.com/', 'type_name': 'Restaurant'})
	print(nyc_eatery_permits.popitem())
		('2027-03-31', {'name': 'Dyckman Marina Restaurant', 'location': 'Dyckman Marina Restaurant', 'park_id': 'M028', 'start_date': '2012-04-01', 'end_date': '2027-03-31', 'description': None, 'permit_number': 'M28-R', 'phone': None, 'website': None, 'type_name': 'Restaurant'})

OrderedDict power feature (2)
	You can use the last=False keyword argument to return the items in insertion order
	
	print(nyc_eatery_permits.popitem(last=False))
		('2012-12-07', {'name': 'Mapes Avenue Ballfields Mobile Food Truck','location': 'Prospect Avenue, E. 181st Street', 'park_id': 'X289','start_date': '2009-07-01', 'end_date': '2012-12-07','description': None, 'permit_number': 'X289-MT', 'phone': None,'website': None, 'type_name': 'Mobile Food Truck'})

Exercise - Working with OrderedDictionaries

Recently in Python 3.6, dictionaries were made to maintain the order in which the keys were inserted; however, in all versions prior to that you need to use an OrderedDict to maintain insertion order.

Let's create a dictionary of all the stop times by route and rider, then use it to find the ridership throughout the day.

		# Import OrderedDict from collections
		from collections import OrderedDict

		# Create an OrderedDict called: ridership_date
		ridership_date = OrderedDict()

		# Iterate over the entries
		for date, riders in entries:
			# If a key does not exist in ridership_date, set it to 0
			if not date in ridership_date:
				ridership_date[date] = 0
				
			# Add riders to the date key in ridership_date
			ridership_date[date] += riders
			
		# Print the first 31 records
		print(list(ridership_date.items())[:31])

Exercise - Powerful Ordered popping

Where OrderedDicts really shine is when you need to access the data in the dictionary in the order you added it. OrderedDict has a .popitem() method that will return items in reverse of which they were inserted. You can also pass .popitem() the last=False keyword argument and go through the items in the order of how they were added.

Here, you'll use the ridership_date OrderedDict you created in the previous exercise.

		# Print the first key in ridership_date
		print(list(ridership_date.keys())[0])

		# Pop the first item from ridership_date and print it
		print(ridership_date.popitem(last=False))

		# Print the last key in ridership_date
		print(list(ridership_date.keys())[-1])

		# Pop the last item from ridership_date and print it
		print(ridership_date.popitem())


What is a namedtuple?
	A tuple where each position (column) has a name
	Ensure each one has the same properties
	Alternative to a pandas DataFrame row

Creating a namedtuple
	Pass a name and a list of fields
	
	from collections import namedtuple
	Eatery = namedtuple('Eatery', ['name', 'location', 'park_id','type_name'])
	eateries = []
	for eatery in nyc_eateries:
		details = Eatery(eatery['name'],
		eatery['location'],
		eatery['park_id'],
		eatery['type_name'])
		eateries.append(details)
	print(eateries[0])
		Eatery(name='Mapes Avenue Ballfields Mobile Food Truck',location='Prospect Avenue, E. 181st Street',park_id='X289', type_name='Mobile Food Truck')

Leveraging namedtuples
	Each field is available as an attribute of the namedtuple
	
	for eatery in eateries[:3]:
		print(eatery.name)
		print(eatery.park_id)
		print(eatery.location)

Exercise - Creating namedtuples for storing data

Often times when working with data, you will use a dictionary just so you can use key names to make reading the code and accessing the data easier to understand. Python has another container called a namedtuple that is a tuple, but has names for each position of the tuple. You create one by passing a name for the tuple type and a list of field names.

For example, Cookie = namedtuple("Cookie", ['name', 'quantity']) will create a container, and you can create new ones of the type using Cookie('chocolate chip', 1) where you can access the name using the name attribute, and then get the quantity using the quantity attribute.

In this exercise, you're going to restructure the transit data you've been working with into namedtuples for more descriptive code.

		# Import namedtuple from collections
		from collections import namedtuple

		# Create the namedtuple: DateDetails
		DateDetails = namedtuple('DateDetails', ['date', 'stop', 'riders'])

		# Create the empty list: labeled_entries
		labeled_entries = []

		# Iterate over the entries
		for date, stop, riders in entries:
			# Append a new DateDetails namedtuple instance for each entry to labeled_entries
			labeled_entries.append(DateDetails(date, stop, riders))
			
		# Print the first 5 items in labeled_entries
		print(labeled_entries[:5])

Exercise - Leveraging attributes on namedtuples

Once you have a namedtuple, you can write more expressive code that is easier to understand. Remember, you can access the elements in the tuple by their name as an attribute. For example, you can access the date of the namedtuples in the previous exercise using the .date attribute.

Here, you'll use the tuples you made in the previous exercise to see how this works.

		# Iterate over the first twenty items in labeled_entries
		for item in labeled_entries[:20]:
			# Print each item's stop
			print(item.stop)

			# Print each item's date
			print(item.date)

			# Print each item's riders
			print(item.riders)
	
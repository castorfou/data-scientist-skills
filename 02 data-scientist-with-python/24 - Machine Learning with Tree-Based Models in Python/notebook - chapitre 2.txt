Difficulties in Approximating f

	Overfitting: fchap fits the training set noise
	Underfitting: fchap is not flexible enough to approximate f

Generalization Error

	Generalization Error of fchap: Does fchap generalize well on unseen data?
	It can be decomposed as follows: 
	Generalization Error of	fchap 
	= bias^2 + variance + irreducible error
	
K-Fold CV in sklearn on the Auto Dataset
	from sklearn.tree import DecisionTreeRegressor
	from sklearn.model_selection import train_test_split
	from sklearn.metrics import mean_squared_error as MSE
	from sklearn.model_selection import cross_val_score
	# Set seed for reproducibility
	SEED = 123
	# Split data into 70% train and 30% test
	X_train, X_test, y_train, y_test = train_test_split(X,y,
		test_size=0.3,
		random_state=SEED)
	# Instantiate decision tree regressor and assign it to 'dt'
	dt = DecisionTreeRegressor(max_depth=4,
		min_samples_leaf=0.14,
		random_state=SEED)
	# Evaluate the list of MSE ontained by 10-fold CV
	# Set n_jobs to -1 in order to exploit all CPU cores in computation
	MSE_CV = - cross_val_score(dt, X_train, y_train, cv= 10,
		scoring='neg_mean_squared_error',
		n_jobs = -1)
	# Fit 'dt' to the training set
	dt.fit(X_train, y_train)
	# Predict the labels of training set
	y_predict_train = dt.predict(X_train)
	# Predict the labels of test set
	y_predict_test = dt.predict(X_test)

	# CV MSE
	print('CV MSE: {:.2f}'.format(MSE_CV.mean()))
		CV MSE: 20.51
	# Training set MSE
	print('Train MSE: {:.2f}'.format(MSE(y_train, y_predict_train)))
		Train MSE: 15.30
	# Test set MSE
	print('Test MSE: {:.2f}'.format(MSE(y_test, y_predict_test)))
		Test MSE: 20.92
	
Given that the training set error (MSE) is smaller than the CV error, we can deduce that dt overfits the training set and suffers from high variance.

Exercise - Instantiate the model

In the following set of exercises, you'll diagnose the bias and variance problems of a regression tree. The regression tree you'll define in this exercise will be used to predict the mpg consumption of cars from the auto dataset using all available features.

We have already processed the data and loaded the features matrix X and the array y in your workspace. In addition, the DecisionTreeRegressor class was imported from sklearn.tree.

		# Import train_test_split from sklearn.model_selection
		from sklearn.model_selection import train_test_split

		# Set SEED for reproducibility
		SEED = 1

		# Split the data into 70% train and 30% test
		X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=SEED)

		# Instantiate a DecisionTreeRegressor dt
		dt = DecisionTreeRegressor(max_depth=4, min_samples_leaf=0.26, random_state=SEED)

Exercise - Evaluate the 10-fold CV error

In this exercise, you'll evaluate the 10-fold CV Root Mean Squared Error (RMSE) achieved by the regression tree dt that you instantiated in the previous exercise.

In addition to dt, the training data including X_train and y_train are available in your workspace. We also imported cross_val_score from sklearn.model_selection.

Note that since cross_val_score has only the option of evaluating the negative MSEs, its output should be multiplied by negative one to obtain the MSEs.

		# Compute the array containing the 10-folds CV MSEs
		MSE_CV_scores = - cross_val_score(dt, X_train, y_train, cv=10, 
							   scoring='neg_mean_squared_error',
							   n_jobs=-1)

		# Compute the 10-folds CV RMSE
		RMSE_CV = (MSE_CV_scores.mean())**(1/2)

		# Print RMSE_CV
		print('CV RMSE: {:.2f}'.format(RMSE_CV))

<script.py> output:
    CV RMSE: 5.14
	
Great work! A very good practice is to keep the test set untouched until you are confident about your model's performance. CV is a great technique to get an estimate of a model's performance without affecting the test set.

Exercise - Evaluate the training error

You'll now evaluate the training set RMSE achieved by the regression tree dt that you instantiated in a previous exercise.

In addition to dt, X_train and y_train are available in your workspace.

		# Import mean_squared_error from sklearn.metrics as MSE
		from sklearn.metrics import mean_squared_error as MSE

		# Fit dt to the training set
		dt.fit(X_train, y_train)

		# Predict the labels of the training set
		y_pred_train = dt.predict(X_train)

		# Evaluate the training set RMSE of dt
		RMSE_train = (MSE(y_train, y_pred_train))**(1/2)

		# Print RMSE_train
		print('Train RMSE: {:.2f}'.format(RMSE_train))

<script.py> output:
    Train RMSE: 5.15
	
Awesome! Notice how the training error is roughly equal to the 10-folds CV error you obtained in the previous exercice.

Exercise - High bias or high variance?

In this exercise you'll diagnose whether the regression tree dt you trained in the previous exercise suffers from a bias or a variance problem.

The training set RMSE (RMSE_train) and the CV RMSE (RMSE_CV) achieved by dt are available in your workspace. In addition, we have also loaded a variable called baseline_RMSE which corresponds to the root mean-squared error achieved by the regression-tree trained with the disp feature only (it is the RMSE achieved by the regression tree trained in chapter 1, lesson 3). Here baseline_RMSE serves as the baseline RMSE above which a model is considered to be underfitting and below which the model is considered 'good enough'.

Does dt suffer from a high bias or a high variance problem?

In [1]: print(RMSE_train)
5.15

In [3]: print(RMSE_CV)
5.14

In [4]: print(baseline_RMSE)
5.1

Correct! dt is indeed underfitting the training set as the model is too constrained to capture the nonlinear dependencies between features and labels.

Voting Classifier in sklearn

	# Import functions to compute accuracy and split data
	from sklearn.metrics import accuracy_score
	from sklearn.model_selection import train_test_split
	# Import models, including VotingClassifier meta-model
	from sklearn.linear_model import LogisticRegression
	from sklearn.tree import DecisionTreeClassifier
	from sklearn.neighbors import KNeighborsClassifier as KNN
	from sklearn.ensemble import VotingClassifier
	# Set seed for reproducibility
	SEED = 1
	# Split data into 70% train and 30% test
	X_train, X_test, y_train, y_test = train_test_split(X, y,
		test_size= 0.3,
		random_state= SEED)
	# Instantiate individual classifiers
	lr = LogisticRegression(random_state=SEED)
	knn = KNN()
	dt = DecisionTreeClassifier(random_state=SEED)
	# Define a list called classifier that contains the tuples (classifier_name, classifier)
	classifiers = [('Logistic Regression', lr),
		('K Nearest Neighbours', knn),
		('Classification Tree', dt)]
	# Iterate over the defined list of tuples containing the classifiers
	for clf_name, clf in classifiers:
		#fit clf to the training set
		clf.fit(X_train, y_train)
		# Predict the labels of the test set
		y_pred = clf.predict(X_test)
		# Evaluate the accuracy of clf on the test set
		print('{:s} : {:.3f}'.format(clf_name, accuracy_score(y_test, y_pred)))

	Logistic Regression: 0.947
	K Nearest Neighbours: 0.930
	Classification Tree: 0.930

	# Instantiate a VotingClassifier 'vc'
	vc = VotingClassifier(estimators=classifiers)
	# Fit 'vc' to the traing set and predict test set labels
	vc.fit(X_train, y_train)
	y_pred = vc.predict(X_test)
	# Evaluate the test-set accuracy of 'vc'
	print('Voting Classifier: {.3f}'.format(accuracy_score(y_test, y_pred)))

Exercise - Define the ensemble

In the following set of exercises, you'll work with the Indian Liver Patient Dataset from the UCI Machine learning repository.

In this exercise, you'll instantiate three classifiers to predict whether a patient suffers from a liver disease using all the features present in the dataset.

The classes LogisticRegression, DecisionTreeClassifier, and KNeighborsClassifier under the alias KNN are available in your workspace.

		# Set seed for reproducibility
		SEED=1

		# Instantiate lr
		lr = LogisticRegression(random_state=SEED)

		# Instantiate knn
		knn = KNN(n_neighbors=27)

		# Instantiate dt
		dt = DecisionTreeClassifier(min_samples_leaf=0.13, random_state=SEED)

		# Define the list classifiers
		classifiers = [('Logistic Regression', lr), ('K Nearest Neighbours', knn), ('Classification Tree', dt)]

Exercise - Evaluate individual classifiers

In this exercise you'll evaluate the performance of the models in the list classifiers that we defined in the previous exercise. You'll do so by fitting each classifier on the training set and evaluating its test set accuracy.

The dataset is already loaded and preprocessed for you (numerical features are standardized) and it is split into 70% train and 30% test. The features matrices X_train and X_test, as well as the arrays of labels y_train and y_test are available in your workspace. In addition, we have loaded the list classifiers from the previous exercise, as well as the function accuracy_score() from sklearn.metrics.

		# Iterate over the pre-defined list of classifiers
		for clf_name, clf in classifiers:    
		 
			# Fit clf to the training set
			clf.fit(X_train, y_train)    
		   
			# Predict y_pred
			y_pred = clf.predict(X_test)
			
			# Calculate accuracy
			accuracy = accuracy_score(y_test, y_pred) 
		   
			# Evaluate clf's accuracy on the test set
			print('{:s} : {:.3f}'.format(clf_name, accuracy))

<script.py> output:
    Logistic Regression : 0.747
    K Nearest Neighbours : 0.724
    Classification Tree : 0.730

Exercise - Better performance with a Voting Classifier

Finally, you'll evaluate the performance of a voting classifier that takes the outputs of the models defined in the list classifiers and assigns labels by majority voting.

X_train, X_test,y_train, y_test, the list classifiers defined in a previous exercise, as well as the function accuracy_score from sklearn.metrics are available in your workspace.

		# Import VotingClassifier from sklearn.ensemble
		from sklearn.ensemble import VotingClassifier

		# Instantiate a VotingClassifier vc
		vc = VotingClassifier(estimators=classifiers)     

		# Fit vc to the training set
		vc.fit(X_train, y_train)   

		# Evaluate the test set predictions
		y_pred = vc.predict(X_test)

		# Calculate accuracy score
		accuracy = accuracy_score(y_test, y_pred)
		print('Voting Classifier: {:.3f}'.format(accuracy))

<script.py> output:
    Voting Classifier: 0.753
	
Great work! Notice how the voting classifier achieves a test set accuracy of 75.3%. This value is greater than that achieved by LogisticRegression.

	


Creating and looping through dictionaries
	Hold data in key/value pairs
	Nestable (use a dictionary as the value of a key within a dictionary)
	Iterable
	Created by dict() or {}
	
	art_galleries = {}
	for name, zip_code in galleries:
		art_galleries[name] = zip_code
	for name in art_galleries:
		print(name)
			Zwirner David Gallery

Safely finding by key (cont.)
	.get() method allows you to safely access a key without error or exception handling
	If a key is not in the dictionary, .get() returns None by default or you 	can supply a value to return
	art_galleries.get('Louvre', 'Not Found')
		Out[5]: 'Not Found'
		
Working with nested data
	The .keys() method shows the keys for a given dictionary
	Common way to deal with repeating data structures
	Can be accessed using multiple indices or the .get() method

	art_galleries.keys()
		dict_keys(['10021', '10013', '10001', '10009', '10011', '10022', '10027', '10019', '11106', '10128'])
	print(art_galleries['10027'])
		{"Paige's Art Gallery": '(212) 531-1577',
		'Triple Candie': '(212) 865-0783',
		'Africart Motherland Inc': '(212) 368-6802',
		'Inner City Art Gallery Inc': '(212) 368-4941'}
	art_galleries['10027']['Inner City Art Gallery Inc']
		Out[3]: '(212) 368-4941'

Exercise - Creating and looping through dictionaries

You'll often encounter the need to loop over some array type data, like in Chapter 1, and provide it some structure so you can find the data you desire quickly.

You start that by creating an empty dictionary and assigning part of your array data as the key and the rest as the value.

Previously, you used sorted() to organize your data in a list. Dictionaries can also be sorted. By default, using sorted() on a dictionary will sort by the keys of the dictionary. You can also reverse the order by passing reverse=True as a keyword argument.

Finally, since sorted returns a list, you can use slice notation to select only part of the list. For example, [:10] will slice the first ten items off a list and return only those items.

		# Create an empty dictionary: names
		names = {}

		# Loop over the girl names
		for name, rank in female_baby_names_2012.items():
			# Add each name to the names dictionary using rank as the key
			names[rank] = name
			
		# Sort the names list by rank in descending order and slice the first 10 items
		for rank in sorted(names):
			# Print each item
			print(names[rank])

Exercise - Safely finding by key

As demonstrated in the video, if you attempt to access a key that isn't present in a dictionary, you'll get a KeyError. One option to handle this type of error is to use a try: except: block. You can learn more about error handling in Python Data Science Toolbox (Part 1), specifically in this video.

Python provides a faster, more versatile tool to help with this problem in the form of the .get() method. The .get() method allows you to supply the name of a key, and optionally, what you'd like to have returned if the key is not found.

You'll be using same names dictionary from the previous exercise and will gain practice using the .get() method.

		# Safely print rank 7 from the names dictionary
		print(names.get(7))

		# Safely print the type of rank 100 from the names dictionary
		print(type(names.get(100)))

		# Safely print rank 105 from the names dictionary or 'Not Found'
		print(names.get(105,'Not Found'))			
		
Exercise - Dealing with nested data

A dictionary can contain another dictionary as the value of a key, and this is a very common way to deal with repeating data structures such as yearly, monthly or weekly data. All the same rules apply when creating or accessing the dictionary.

For example, if you had a dictionary that had a ranking of my cookie consumption by year and type of cookie. It might look like cookies = {'2017': {'chocolate chip': 483, 'peanut butter': 115}, '2016': {'chocolate chip': 9513, 'peanut butter': 6792}}. I could access how many chocolate chip cookies I ate in 2016 using cookies['2016']['chocolate chip'].

When exploring a new dictionary, it can be helpful to use the .keys() method to get an idea of what data might be available within the dictionary. You can also iterate over a dictionary and it will return each key in the dictionary for you to use inside the loop. Here, a dictionary called boy_names has been loaded into your workspace. It consists of all male names in 2013 and 2014.

		# Print a list of keys from the boy_names dictionary
		print(boy_names.keys())

		# Print a list of keys from the boy_names dictionary for the year 2013
		print(boy_names[2013].keys())

		# Loop over the dictionary
		for year in boy_names:
			# Safely print the year and the third ranked name or 'Unknown'
			print(year, boy_names[year].get(3, 'Unknown'))
			
Excellent work! Dealing with nested dictionaries can be tricky. Here, the 2012 key consists of an empty dictionary, and so there is no third ranked name. As a result, 'Unknown' is printed, unlike for 2013 and 2014.			
			
Adding and extending dictionaries
	Assignment to add a new key/value to a dictionary
	.update() method to update a dictionary from another dictionary,
	tuples or keywords
		
	print(galleries_10007)
		{'Nyabinghi Africian Gift Shop': '(212) 566-3336'}
	art_galleries['10007'] = galleries_10007
	galleries_11234 = [('A J ARTS LTD', '(718) 763-5473'), ('Doug Meyer Fine Art', '(718) 375-8006'), ('Portrait Gallery', '(718) 377-8762')]
	art_galleries['11234'].update(galleries_11234)
	print(art_galleries['11234'])
		{'Portrait Gallery': '(718) 377-8762', 'A J ARTS LTD': '(718) 763-5473','Doug Meyer Fine Art': '(718) 375-8006'}

Popping and deleting from dictionaries
	del instruction deletes a key/value
	.pop() method safely removes a key/value from a dictionary.

	del art_galleries['11234']
	galleries_10310 = art_galleries.pop('10310')
	print(galleries_10310)
		{'New Dorp Village Antiques Ltd': '(718) 815-2526'}

Exercise - Adding and extending dictionaries

If you have a dictionary and you want to add data to it, you can simply create a new key and assign the data you desire to it. It's important to remember that if it's a nested dictionary, then all the keys in the data path must exist, and each key in the path must be assigned individually.

You can also use the .update() method to update a dictionary with keys and values from another dictionary, tuples or keyword arguments.

Here, you'll combine several techniques used in prior exercises to setup your dictionary in a way that makes it easy to find the least popular baby name for each year.

Your job is to add data for the year 2011 to your dictionary by assignment, 2012 by update, and then find the least popular baby name for each year.

		# Assign the names_2011 dictionary as the value to the 2011 key of boy_names
		boy_names[2011] = names_2011

		# Update the 2012 key in the boy_names dictionary
		boy_names[2012].update([(1, 'Casey'), (2, 'Aiden')])

		# Loop over the boy_names dictionary 
		for year in boy_names:
			# Loop over and sort the data for each year by descending rank
			for rank in sorted(boy_names[year], reverse=True)[:1]:
				# Check that you have a rank
				if not rank:
					print(year, 'No Data Available')
				# Safely print the year and the least popular name or 'Not Available'
				print(year, boy_names.get(rank,'Not Available'))	

Exercise - Popping and deleting from dictionaries

Often, you will want to remove keys and value from a dictionary. You can do so using the del Python instruction. It's important to remember that del will throw a KeyError if the key you are trying to delete does not exist. You can not use it with the .get() method to safely delete items; however, it can be used with try: catch:.

If you want to save that deleted data into another variable for further processing, the .pop() dictionary method will do just that. You can supply a default value for .pop() much like you did for .get() to safely deal with missing keys. It's also typical to use .pop() instead of del since it is a safe method.

Here, you'll remove 2011 and 2015 to save them for later, and then delete 2012 from the dictionary.

		# Remove 2011 and store it: female_names_2011
		female_names_2011 = female_names.pop(2011)

		# Safely remove 2015 with an empty dictionary as the default: female_names_2015
		female_names_2015 = female_names.pop(2015, {})

		# Delete 2012
		del female_names[2012]

		# Print female_names
		print(female_names)			

Working with dictionaries more pythonically
	.items() method returns an object we can iterate over
	
	for gallery, phone_num in art_galleries.items():
		print(gallery)
		print(phone_num)
			'Miakey Art Gallery'
			'(718) 686-0788'
			'Morning Star Gallery Ltd'
			'(212) 334-9330'}
			'New York Art Expo Inc'
			'(212) 363-8280'

Checking dictionaries for data
	.get() does a lot of work to check for a key
	in operator is much more efficient and clearer
	
	'11234' in art_galleries
		Out[1]: False
	if '10010' in art_galleries:
		print('I found: %s' % art_galleries['10010'])
	else:
		print('No galleries found.')
			I found: {'Nyabinghi Africian Gift Shop': '(212) 566-3336'}
			
Exercise - Working with dictionaries more pythonically

So far, you've worked a lot with the keys of a dictionary to access data, but in Python, the prefered manner for iterating over items in a dictionary is with the .items() method.

This returns each key and value from the dictionary as a tuple, which you can unpack in a for loop. You'll now get practice doing this.

		# Iterate over the 2014 nested dictionary
		for rank, name in  baby_names[2014].items():
			# Print rank and name
			print(rank, name)
			
		# Iterate over the 2012 nested dictionary
		for rank, name in  baby_names[2012].items():
			# Print rank and name
			print(rank, name)

Nicely done. Using the .items() method to iterate over dictionaries is something you'll be doing very frequently in Python.

Exercise - Checking dictionaries for data

You can check to see if a key exists in a dictionary by using the in expression.

For example, you can check to see if 'cookies' is a key in the dictionary by using if 'cookies' in recipes_dict: this allows you to safely react to data being present in the dictionary.

You can also use the in expression so see if data is in the value of a dictionary such as if 'cookies' in recipes_dict.values(). Remember you have to handle nested dictionaries differently as illustrated in the video and previous exercises, and use the in expression on each nested dictionary.

		# Check to see if 2011 is in baby_names
		if 2011 in baby_names:
			# Print 'Found 2011'
			print('Found 2011')
			
		# Check to see if rank 1 is in 2012
		if 1 in baby_names[2012]:
			# Print 'Found Rank 1 in 2012' if found
			print('Found Rank 1 in 2012')
		else:
			# Print 'Rank 1 missing from 2012' if not found
			print('Rank 1 missing from 2012')
			
		# Check to see if Rank 5 is in 2013
		if 5 in baby_names[2013]:
		   # Print 'Found Rank 5'
		   print('Found Rank 5')

Reading from a file using CSV reader
	Python csv module
	open() function provides a variable that represents a file, takes a path and a mode
	csv.reader() reads a file object and returns the lines from the file as tuples
	.close() method closes file objects
	
	import csv
	csvfile = open('ART_GALLERY.csv', 'r')
	for row in csv.reader(csvfile): print(row)
		['NAME', 'the_geom', 'TEL', 'URL', 'ADDRESS1', 'ADDRESS2', 'CITY', 'ZIP']
		["O'reilly William & Co Ltd",'POINT (-73.96273074561996 40.773800871637576)','(212) 396-1822', '52 E 76th St', '', 'New York', '10021']
	csvfile.close()

Creating a dictionary from a file
	Often we want to go from CSV file to dictionary
	DictReader does just that
	If data doesn't have a header row, you can pass in the column names
	
	import csv
	csvfile = open('ART_GALLERY.csv', 'r')
	for row in csv.DictReader(csvfile): print(row)
		OrderedDict([('NAME', 'Odyssia Gallery'),
		('the_geom', 'POINT (-73.96269813635554 40.7618747512849)'),
		('TEL', '(212) 486-7338'),
		('URL', 'http://www.livevillage.com/newyork/art/odyssia-gallery.html'),
		('ADDRESS1', '305 E 61st St'),
		('ADDRESS2', ''),
		('CITY', 'New York'), ('ZIP', '10021')])
	csvfile.close()

Exercise - Reading from a file using CSV reader

Python provides a wonderful module called csv to work with CSV files. You can pass the .reader() method of csv a Python file object and use it as you would any other iterable. To create a Python file object, you use the open() function, which accepts a file name and a mode. The mode is typically 'r' for read or 'w' for write.

Though you won't use it for this exercise, often CSV files will have a header row with field names, and you will need to use slice notation such as [1:] to skip the header row.

You'll now use the csv module to read the baby_names.csv file and fill the baby_names dictionary with data. This baby_names dictionary has already been created for you.

		# Import the python CSV module
		import csv

		# Create a python file object in read mode for the baby_names.csv file: csvfile
		csvfile = open('baby_names.csv', 'r')

		# Loop over a csv reader on the file object
		for row in csv.reader(csvfile):
			# Print each row 
			print(row)
			# Add the rank and name to the dictionary
			baby_names[row[5]] = row[3]

		# Print the dictionary keys
		print(baby_names.keys())

		csvfile.close()

Fantastic work! CSV files are among the most common methods of storing tabular data, and you'll encounter them in the wild very frequently. As a result, knowing how to leverage the csv module can be a great addition to your data science toolbox.

Exercise - Creating a dictionary from a file

The csv module also provides a way to directly create a dictionary from a CSV file with the DictReader class. If the file has a header row, that row will automatically be used as the keys for the dictionary. However, if not, you can supply a list of keys to be used. Each row from the file is returned as a dictionary. Using DictReader can make it much easier to read your code and understand what data is being used, especially when compared to the numbered indexes you used in the prior exercise.

Your job in this exercise is to create a dictionary directly from the data file using DictReader. NOTE: The misspellings are from the original data, and this is a very common issue. Again, the baby_names dictionary has already been created for you.

		# Import the python CSV module
		import csv

		# Create a python file object in read mode for the `baby_names.csv` file: csvfile
		csvfile = open('baby_names.csv', 'r')

		# Loop over a DictReader on the file
		for row in csv.DictReader(csvfile):
			# Print each row 
			print(row)
			# Add the rank and name to the dictionary: baby_names
			baby_names[row['RANK']] = row['NAME']

		# Print the dictionary keys
		print(baby_names.keys())
		   
#!/usr/bin/env python
# coding: utf-8

# # Encoding text

# ## Cleaning up your text
# Unstructured text data cannot be directly used in most analyses. Multiple steps need to be taken to go from a long free form string to a set of numeric columns in the right format that can be ingested by a machine learning model. The first step of this process is to standardize the data and eliminate any characters that could cause problems later on in your analytic pipeline.
# 
# In this chapter you will be working with a new dataset containing the inaugural speeches of the presidents of the United States loaded as speech_df, with the speeches stored in the text column.

# ### init: 1 dataframe

# In[1]:


from uploadfromdatacamp import saveFromFileIO

#uploadToFileIO(speech_df)
tobedownloaded="{pandas.core.frame.DataFrame: {'speech_df.csv': 'https://file.io/dwon3s'}}"
prefix='data_from_datacamp/Chap4-Exercise1.1_'
#saveFromFileIO(tobedownloaded, prefix=prefix, proxy="10.225.92.1:80")


# In[2]:


import pandas as pd
speech_df=pd.read_csv(prefix+'speech_df.csv',index_col=0)


# ### code

# In[3]:


# Print the first 5 rows of the text column
print(speech_df['text'].head())


# In[4]:


# Replace all non letter characters with a whitespace
speech_df['text_clean'] = speech_df['text'].str.replace('[^a-zA-Z]', ' ')

# Change to lower case
speech_df['text_clean'] = speech_df['text_clean'].str.lower()

# Print the first 5 rows of the text_clean column
print(speech_df['text_clean'].head())


# ## High level text features
# Once the text has been cleaned and standardized you can begin creating features from the data. The most fundamental information you can calculate about free form text is its size, such as its length and number of words. In this exercise (and the rest of this chapter), you will focus on the cleaned/transformed text column (text_clean) you created in the last exercise.

# In[7]:


# Find the length of each text
speech_df['char_cnt'] = speech_df['text_clean'].str.len()

# Count the number of words in each text
speech_df['word_cnt'] = speech_df['text_clean'].str.split().str.len()

# Find the average length of word
speech_df['avg_word_length'] = speech_df['char_cnt'] / speech_df['word_cnt']

# Print the first 5 rows of these columns
print(speech_df[['text_clean', 'char_cnt', 'word_cnt', 'avg_word_length']])


# # Word counts

# ## Counting words (I)
# Once high level information has been recorded you can begin creating features based on the actual content of each text. One way to do this is to approach it in a similar way to how you worked with categorical variables in the earlier lessons.
# 
# For each unique word in the dataset a column is created.
# For each entry, the number of times this word occurs is counted and the count value is entered into the respective column.
# These "count" columns can then be used to train machine learning models.

# ### code

# In[9]:


# Import CountVectorizer
from sklearn.feature_extraction.text import CountVectorizer

# Instantiate CountVectorizer
cv = CountVectorizer()

# Fit the vectorizer
cv.fit(speech_df['text_clean'])

# Print feature names
print(cv.get_feature_names())


# ## Counting words (II)
# Once the vectorizer has been fit to the data, it can be used to transform the text to an array representing the word counts. This array will have a row per block of text and a column for each of the features generated by the vectorizer that you observed in the last exercise.
# 
# The vectorizer to you fit in the last exercise (cv) is available in your workspace.

# ### code

# In[11]:


# Apply the vectorizer
cv_transformed = cv.transform(speech_df['text_clean'])

# Print the full array
cv_array = cv_transformed.toarray()
print(cv_array)


# In[12]:


# Print the shape of cv_array
print(cv_array.shape)


# ## Limiting your features
# As you have seen, using the CountVectorizer with its default settings creates a feature for every single word in your corpus. This can create far too many features, often including ones that will provide very little analytical value.
# 
# For this purpose CountVectorizer has parameters that you can set to reduce the number of features:
# 
# min_df : Use only words that occur in more than this percentage of documents. This can be used to remove outlier words that will not generalize across texts.
# max_df : Use only words that occur in less than this percentage of documents. This is useful to eliminate very common words that occur in every corpus without adding value such as "and" or "the".

# ### code

# In[14]:


# Import CountVectorizer
from sklearn.feature_extraction.text import CountVectorizer

# Specify arguements to limit the number of features generated
cv = CountVectorizer(min_df=0.2, max_df=0.8)

# Fit, transform, and convert into array
cv_transformed = cv.fit_transform(speech_df['text_clean'])
cv_array = cv_transformed.toarray()

# Print the array shape
print(cv_array.shape)


# ## Text to DataFrame
# Now that you have generated these count based features in an array you will need to reformat them so that they can be combined with the rest of the dataset. This can be achieved by converting the array into a pandas DataFrame, with the feature names you found earlier as the column names, and then concatenate it with the original DataFrame.
# 
# The numpy array (cv_array) and the vectorizer (cv) you fit in the last exercise are available in your workspace.

# ### code

# - Create a DataFrame cv_df containing the cv_array as the values and the feature names as the column names.
# - Add the prefix Counts_ to the column names for ease of identification.
# - Concatenate this DataFrame (cv_df) to the original DataFrame (speech_df) column wise.

# In[15]:


# Create a DataFrame with these features
cv_df = pd.DataFrame(cv_array, 
                     columns=cv.get_feature_names()).add_prefix('Counts_')

# Add the new columns to the original DataFrame
speech_df_new = pd.concat([speech_df, cv_df], axis=1, sort=False)
print(speech_df_new.head())


# # Term frequency-inverse document frequency
# 

# ## Tf-idf
# While counts of occurrences of words can be useful to build models, words that occur many times may skew the results undesirably. To limit these common words from overpowering your model a form of normalization can be used. In this lesson you will be using Term frequency-inverse document frequency (Tf-idf) as was discussed in the video. Tf-idf has the effect of reducing the value of common words, while increasing the weight of words that do not occur in many documents.

# ### code

# In[18]:


# Import TfidfVectorizer
from sklearn.feature_extraction.text import TfidfVectorizer

# Instantiate TfidfVectorizer
tv = TfidfVectorizer(max_features=100, stop_words='english')

# Fit the vectroizer and transform the data
tv_transformed = tv.fit_transform(speech_df['text_clean'])

# Create a DataFrame with these features
tv_df = pd.DataFrame(tv_transformed.toarray(), 
                     columns=tv.get_feature_names()).add_prefix('TFIDF_')
print(tv_df.head())


# ## Inspecting Tf-idf values
# After creating Tf-idf features you will often want to understand what are the most highest scored words for each corpus. This can be achieved by isolating the row you want to examine and then sorting the the scores from high to low.
# 
# The DataFrame from the last exercise (tv_df) is available in your workspace.

# In[21]:


# Isolate the row to be examined
sample_row = tv_df.loc[0]

# Print the top 5 words of the sorted output
print(sample_row.sort_values(ascending=False).head())


# ## Transforming unseen data
# When creating vectors from text, any transformations that you perform before training a machine learning model, you also need to apply on the new unseen (test) data. To achieve this follow the same approach from the last chapter: fit the vectorizer only on the training data, and apply it to the test data.
# 
# For this exercise the speech_df DataFrame has been split in two:
# 
# train_speech_df: The training set consisting of the first 45 speeches.
# test_speech_df: The test set consisting of the remaining speeches.

# ### init: 2 dataframes

# In[22]:


from uploadfromdatacamp import saveFromFileIO

#uploadToFileIO(train_speech_df,test_speech_df)
tobedownloaded="{pandas.core.frame.DataFrame: {'test_speech_df.csv': 'https://file.io/ITiVir',  'train_speech_df.csv': 'https://file.io/kmshHo'}}"
prefix='data_from_datacamp/Chap4-Exercise3.3_'
#saveFromFileIO(tobedownloaded, prefix=prefix, proxy="10.225.92.1:80")


# In[23]:


import pandas as pd
train_speech_df=pd.read_csv(prefix+'train_speech_df.csv',index_col=0)
test_speech_df=pd.read_csv(prefix+'test_speech_df.csv',index_col=0)


# ### code

# In[26]:


# Instantiate TfidfVectorizer
tv = TfidfVectorizer(max_features=100, stop_words='english')

# Fit the vectroizer and transform the data
tv_transformed = tv.fit_transform(train_speech_df['text_clean'])

# Transform test data
test_tv_transformed = tv.transform(test_speech_df['text_clean'])

# Create new features for the test set
test_tv_df = pd.DataFrame(test_tv_transformed.toarray(), 
                          columns=tv.get_feature_names()).add_prefix('TFIDF_')
print(test_tv_df.head())


# # N-grams

# ## Using longer n-grams
# So far you have created features based on individual words in each of the texts. This can be quite powerful when used in a machine learning model but you may be concerned that by looking at words individually a lot of the context is being ignored. To deal with this when creating models you can use n-grams which are sequence of n words grouped together. For example:
# 
# bigrams: Sequences of two consecutive words
# trigrams: Sequences of two consecutive words
# These can be automatically created in your dataset by specifying the ngram_range argument as a tuple (n1, n2) where all n-grams in the n1 to n2 range are included.

# ### code

# In[27]:


# Import CountVectorizer
from sklearn.feature_extraction.text import CountVectorizer

# Instantiate a trigram vectorizer
cv_trigram_vec = CountVectorizer(max_features=100, 
                                 stop_words='english', 
                                 ngram_range=(3,3))

# Fit and apply trigram vectorizer
cv_trigram = cv_trigram_vec.fit_transform(speech_df['text_clean'])

# Print the trigram features
print(cv_trigram_vec.get_feature_names())


# ## Finding the most common words
# Its always advisable once you have created your features to inspect them to ensure that they are as you would expect. This will allow you to catch errors early, and perhaps influence what further feature engineering you will need to do.
# 
# The vectorizer (cv) you fit in the last exercise and the sparse array consisting of word counts (cv_trigram) is available in your workspace.

# ### code

# In[32]:


# Create a DataFrame of the features
cv_tri_df = pd.DataFrame(cv_trigram.toarray(), 
                 columns=cv_trigram_vec.get_feature_names()).add_prefix('Counts_')

# Print the top 5 words in the sorted output
print(cv_tri_df.sum().sort_values(ascending=False).head())


# In[ ]:




